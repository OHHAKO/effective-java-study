## 아이템71. 필요 없는 검사예외 사용은 피하라
검사 예외는 발생하는 문제를 개발자가 처리함으로서 프로그램 안정성을 높이도록 합니다.
그러나 과하게 사용하면 되려 불편한 API가 될 수 있습니다.
<br><br>

1. API를 제대로 사용해도 예외가 발생한다
2. 개발자가 유의미한 조치를 취할 수 있다
상황이 하나라도 해당 되면 예외 작성의 불편함을 감수할 수 있습니다. 하지만 해당이 안되면 비검사 예외를 사용하는게 좋습니다.<br>
검사 예외, 비검사 예외 사이의 선택은 개발자가 예외를 **어떻게 다룰것인가**를 결정한 이후의 일입니다.

### 검사 예외 피하기
메서드가 단 하나의 검사 예외만 던질 때, 검사 예외는 작성하기가 부담스럽습니다.<br>
일어날 지도 모르는 상황을 명시해 동작을 결정하려니 흐름을 확신하기도 어렵습니다. <br>
이런 상황이라면 예외를 작성하지 않을 방법을 고민해볼 가치가 있습니다.<br>

검사 예외를 피하는 방법 두 가지가 있습니다.
1. 적절한 결과 타입의 옵셔널을 반환한다
2. 상태 검사 메서드를 사용해 비검사 예외로 바꾼다
<br>

첫번째 방법은 catch를 사용해 검사 예외를 던지는 대신 단순 **빈 옵셔널**을 반환합니다. 작성이 단순하지만 예외 발생의 이유에 대한 정보를 알 수 없는게 단점입니다. 검사 예외를 사용하면 **구체적 예외타입**과 그타입이 제공하는 **메서드** 를 활용할 수 있습니다.<br><br>
두번째는 **검사 예외**를 **비검사 예외** 로 바꾸는 방법입니다.<br> 
catch를 쓰는대신 boolean타입 사용자 메서드를 작성해 동작을 결정하는 것입니다.<br>
예시 코드입니다. <br>

<h5>Before Refactoring</h5>

```java
try{
  obj.action(args);
}catch(TheCheckedException e){
  ...//예외 상황 대처
}
```

<h5>After refactoring</h5>

**actionPermitted()**: 예외를 처리할지 여부를 boolean으로 반환 <br>
예외 발생 시와 미 발생시 객체의 상태 처리를 직관적으로 볼 수 있습니다.
```java
if(obj.actionPermitted(args)){
  obj.action(args);
}else{
  ...//예외 상황에 대처한다
}
```

이 리팩터링은 외부 동기화 없이 멀티스레드가 상태에 **동시 접근** 하는 상황 <br>
또는 외부 요인에 의해 **상태가 변하는** 상황이라면 적절하지 않을 수 있으니 <br>
상황에 따라 유의해서 사용하도록 하자. 검사 예외보다 유연한 것은 확실하다.