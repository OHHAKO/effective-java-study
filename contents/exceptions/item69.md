## 아이템69. 예외는 진짜 예외 상황에만 사용하라

예외는 꼭 필요한 예외 상황에 쓰도록 설계되어 있습니다. <br>
예외를 **일상적인 제어 흐름용**으로 사용하면 효율이 떨어집니다. 

다음은 반복문에 예외를 쓴 코드입니다.
```java
try{
  int i = 0;
  while(true)
    range[i++].climb();
}catch(ArrayIndexOutOfBoundsException e){
  //처리 수행
}
```

표준 관용구를 작성한 코드입니다. 
```java
for(Mountain m : range){
  m.climb();
  }
```
반복문에 쓴 예외는 코드를 헷갈리게 하고 속도, 가독성 또한 떨어집니다.<br>
혹여나 반복문에 버그라도 있다면 전체 코드 디버깅에 혼란을 줍니다. <br><br>

반복문 몸체에서 관련없는 배열을 사용해 ArrayIndexOutOfBoundsException이 발생했다고 가정해봅시다. 아래의 표준 관용구라면 이 버그는 예외를 잡지 않고 스레드를 종료 시킵니다. 반면, 위 반복문 예외는 버그로 발생한 엉뚱한 예외를 **정상적 반복문 종료**로 인식해 넘어가게 됩니다.<br>
개발자가 예외를 써서 특정상태의 동작을 결정하고 싶다면 **API**를 쓰는게 좋습니다. <br>

Iterator 인터페이스를 사용한 코드입니다. <br>
**hasNext()**: 다음 요소가 존재할 때 true를 반환한다<br>
**Next()**: 다음 요소로 이동시킨다
```java
for(Iterator<Foo> i = collection.iterator(); i.hasNext(); ){
  Foo foo = i.next();
  ...
}
```

next는 상태 의존적 메서드 <br> 
hasNext는 상태 검사 메서드 <br> 
- 상태검사 메서드: 상태를 검사하여 결과를 반환한다
- 상태의존적 메서드: 특정 상태에서만 호출할 수 있다
(상태가 올바르지 않을 때 빈 옵셔널 Optional&lt;T&gt;(비어있는 값) 혹은 null 을 반환하는 방법이 있습니다.) <br>
위에서 작성한 표준 관용구, Iterator api는 불필요한 예외 사용이 없었습니다. 잘 설계된 API라면 정상적인 제어 흐름에서 **예외 사용**이 **필요 없도록** 해야 합니다.